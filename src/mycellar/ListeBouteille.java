//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2012.03.18 at 06:16:55 PM CET 
//


package mycellar;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.bind.annotation.XmlType;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.stream.StreamResult;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.LinkedList;

/**
 * <p>Titre : Cave à vin</p>
 * <p>Description : Votre description</p>
 * <p>Copyright : Copyright (c) 2012</p>
 * <p>Société : Seb Informatique</p>
 * @author Sébastien Duché
 * @version 0.9
 * @since 22/05/18
 *
 * <p>Java class for anonymous complex type.
 *
 * <p>The following schema fragment specifies the expected content contained within this class.
 *
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element ref="{}Bouteille" maxOccurs="unbounded"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 *
 *
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
		"bouteille"
})
@XmlRootElement(name = "ListeBouteille")
@XmlSeeAlso(Bouteille.class)
public class ListeBouteille {

	@XmlElement(name = "Bouteille", required = true)
	LinkedList<Bouteille> bouteille;

	/**
	 * Gets the value of the bouteille property.
	 *
	 * <p>
	 * This accessor method returns a reference to the live list,
	 * not a snapshot. Therefore any modification you make to the
	 * returned list will be present inside the JAXB object.
	 * This is why there is not a <CODE>set</CODE> method for the bouteille property.
	 *
	 * <p>
	 * For example, to add a new item, do as follows:
	 * <pre>
	 *    getBouteille().add(newItem);
	 * </pre>
	 *
	 *
	 * <p>
	 * Objects of the following type(s) are allowed in the list
	 * {@link Bouteille }
	 *
	 *
	 */
	public LinkedList<Bouteille> getBouteille() {
		if (bouteille == null) {
			bouteille = new LinkedList<>();
		}
		return bouteille;
	}

	void resetBouteille() {
		bouteille = null;
	}

	static boolean loadXML() {
		Debug("Loading JAXB File");
		File f = new File(Program.getXMLBottlesFileName());
		return loadXML(f);
	}

	static boolean loadXML(File f) {
		Debug("Loading XML File "+f.getAbsolutePath());
		if(!f.exists())
			return false;
		try {
			unMarshalXML(f);
			return true;
		} catch (Exception e) {
			Debug("ERROR: Unable to Unmarshall JAXB File");
			Program.showException(e, false);
		}
		Debug("Manual loading of the XML file");
		try {
			manualLoadXML(f);
		} catch (ParserConfigurationException | IOException | SAXException e) {
			Debug("ERROR: Unable to load manually File");
			Program.showException(e);
			return false;
		}
		return true;
	}

	private static void manualLoadXML(File f) throws ParserConfigurationException, IOException, SAXException {
		DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
		DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
		Document doc = dBuilder.parse(f);
		doc.getDocumentElement().normalize();

		ListeBouteille listeBouteille = new ListeBouteille();
		NodeList bouteilles = doc.getElementsByTagName("Bouteille");

		for (int i = 0; i < bouteilles.getLength(); i++) {
			Node node = bouteilles.item(i);

			if (node.getNodeType() == Node.ELEMENT_NODE) {
				Element bouteilleElem = (Element) node;
				listeBouteille.getBouteille().add(Bouteille.getBouteilleFromXML(bouteilleElem));
			}
		}
		Program.getStorage().setListBouteilles(listeBouteille);
		Debug("Loading Manually File Done");
	}

	private static void unMarshalXML(File f) throws JAXBException, FileNotFoundException {
		JAXBContext jc = JAXBContext.newInstance(ObjectFactory.class);
		Unmarshaller u = jc.createUnmarshaller();
		ListeBouteille lb =
				(ListeBouteille)u.unmarshal(new FileInputStream(f));
		Program.getStorage().addBouteilles(lb);
		Debug("Loading JAXB File Done");
	}

	static boolean writeXML() {
		return writeXML(Program.getStorage().getListBouteilles(), new File(Program.getXMLBottlesFileName()));
	}

	static boolean writeXML(File f) {
		return writeXML(Program.getStorage().getListBouteilles(), f);
	}

	static boolean writeXML(ListeBouteille liste, File f) {
		Debug("Writing JAXB File");
		try {
			JAXBContext jc = JAXBContext.newInstance(ObjectFactory.class);
			Marshaller m = jc.createMarshaller();
			m.setProperty( Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
			m.marshal(liste, new StreamResult(f));
		} catch( Exception e ) {
			Program.showException(e);
			return false;
		}
		Debug("Writing JAXB File Done");
		return true;
	}

	/**
	 * Debug
	 *
	 * @param sText String
	 */
	public static void Debug(String sText) {
		Program.Debug("ListeBouteille: " + sText );
	}
}
