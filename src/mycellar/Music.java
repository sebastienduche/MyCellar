//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2012.03.18 at 05:32:45 PM CET
//


package mycellar;

import mycellar.core.BottlesStatus;
import mycellar.core.MyCellarObject;
import mycellar.core.common.MyCellarFields;
import mycellar.core.common.music.MusicSupport;
import mycellar.core.datas.jaxb.tracks.Track;
import mycellar.core.datas.jaxb.tracks.Tracks;
import mycellar.placesmanagement.Place;
import mycellar.placesmanagement.Rangement;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;
import java.io.Serializable;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

import static mycellar.general.XmlUtils.getTextContent;

/**
 * <p>Titre : Cave &agrave; vin</p>
 * <p>Description : Votre description</p>
 * <p>Copyright : Copyright (c) 2021</p>
 * <p>Soci&eacute;t&eacute; : Seb Informatique</p>
 * @author S&eacute;bastien Duch&eacute;
 * @version 0.7
 * @since 23/04/21
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "id",
    "title",
    "annee",
    "kind",
    "diskNumber",
    "diskCount",
    "rating",
    "file",
    "emplacement",
    "numLieu",
    "ligne",
    "colonne",
    "prix",
    "comment",
    "artist",
    "composer",
    "genre",
    "duration",
    "status",
    "lastModified",
    "tracks"
})
@XmlRootElement(name = "Music")
public class Music extends MyCellarObject implements Serializable {

  private static final long serialVersionUID = 7443323147347096231L;

  private int id;

  @XmlElement(required = true)
  private String title;
  @XmlElement(required = true)
  private String annee;
  @XmlElement(required = true)
  private String kind;
  @XmlElement(required = true)
  private String emplacement;
  private int numLieu;
  private int ligne;
  private int colonne;
  @XmlElement(required = true)
  private String prix;
  @XmlElement(required = true)
  private String comment;
  @XmlElement(required = true)
  private String artist;
  @XmlElement(required = true)
  private String composer;
  @XmlElement(required = true)
  private String genre;
  @XmlElement()
  private Tracks tracks;
  @XmlElement()
  private String duration;
  @XmlElement()
  private String status;
  @XmlElement()
  private String lastModified;
  @XmlElement()
  private int diskNumber;
  @XmlElement()
  private int diskCount;
  @XmlElement()
  private int rating;
  @XmlElement()
  private String file;

  public Music() {
    title = kind = emplacement = prix = comment = annee = artist = composer = duration = genre = file = "";
    tracks = null;
    status = "";
    lastModified = null;
  }

  public Music(Music music) {
    Objects.requireNonNull(music);
    id = Program.getNewID();
    title = music.getTitle();
    annee = music.getAnnee();
    kind = music.getKind();
    emplacement = music.getEmplacement();
    numLieu = music.getNumLieu();
    ligne = music.getLigne();
    colonne = music.getColonne();
    prix = music.getPrix();
    comment = music.getComment();
    artist = music.getArtist();
    composer = music.getComposer();
    genre = music.getGenre();
    duration = music.getDuration();
    tracks = music.getTracks();
    status = music.getStatus();
    lastModified = music.getLastModified();
    diskNumber = music.getDiskNumber();
    diskCount = music.getDiskCount();
    rating = music.getRating();
    file = music.getFile();
  }

  public Music(MusicBuilder builder) {
    if (builder.id == 0) {
      id = Program.getNewID();
    } else {
      id = builder.id;
    }
    title = builder.nom;
    annee = builder.annee;
    kind = builder.type;
    emplacement = builder.emplacement;
    numLieu = builder.numLieu;
    ligne = builder.ligne;
    colonne = builder.colonne;
    prix = builder.prix;
    comment = builder.comment;
    artist = builder.artist;
    composer = builder.composer;
    genre = builder.genre;
    duration = builder.duration;
    tracks = builder.tracks;
    status = builder.status;
    lastModified = builder.lastModified;
    diskNumber = builder.diskNumber;
    diskCount = builder.diskCount;
    rating = builder.rating;
    file = builder.file;
  }

  @Override
  public int getId() {
    return id;
  }

  @Override
  public void setId(int id) {
    this.id = id;
  }

  @Override
  public String getNom() {
    return getTitle();
  }

  @Override
  public void setNom(String value) {
    setTitle(value);
  }

  public String getTitle() {
    return title;
  }

  public void setTitle(String title) {
    this.title = title;
  }

  @Override
  public String getAnnee() {
    return annee;
  }

  @Override
  public void setAnnee(String annee) {
    this.annee = annee;
  }

  @Override
  public String getKind() {
    return kind;
  }

  @Override
  public void setKind(String kind) {
    this.kind = kind;
  }

  @Override
  public String getEmplacement() {
    return emplacement;
  }

  @Override
  public void setEmplacement(String emplacement) {
    this.emplacement = emplacement;
  }

  @Override
  public int getNumLieu() {
    return numLieu;
  }

  @Override
  public void setNumLieu(int numLieu) {
    this.numLieu = numLieu;
  }

  @Override
  public int getLigne() {
    return ligne;
  }

  @Override
  public void setLigne(int ligne) {
    this.ligne = ligne;
  }

  @Override
  public int getColonne() {
    return colonne;
  }

  @Override
  public void setColonne(int colonne) {
    this.colonne = colonne;
  }

  @Override
  public String getPrix() {
    return prix;
  }

  public void setPrix(String prix) {
    this.prix = prix;
  }

  @Override
  public String getComment() {
    return comment;
  }

  public void setComment(String comment) {
    this.comment = comment;
  }

  public String getArtist() {
    return artist;
  }

  public void setArtist(String artist) {
    this.artist = artist;
  }

  public String getComposer() {
    return composer;
  }

  public void setComposer(String composer) {
    this.composer = composer;
  }

  public String getDuration() {
    return duration;
  }

  public void setDuration(String duration) {
    this.duration = duration;
  }

  public Tracks getTracks() {
    return tracks;
  }

  public void setTracks(Tracks tracks) {
    this.tracks = tracks;
  }

  public String getGenre() {
    return genre;
  }

  public void setGenre(String genre) {
    this.genre = genre;
  }

  @Override
  public String getStatus() {
    return status;
  }

  @Override
  public void setStatus(String status) {
    this.status = status;
  }

  @Override
  public String getLastModified() {
    return lastModified;
  }

  public int getDiskNumber() {
    return diskNumber;
  }

  public void setDiskNumber(int diskNumber) {
    this.diskNumber = diskNumber;
  }

  public int getDiskCount() {
    return diskCount;
  }

  public void setDiskCount(int diskCount) {
    this.diskCount = diskCount;
  }

  public int getRating() {
    return rating;
  }

  public void setRating(int rating) {
    this.rating = rating;
  }

  public String getFile() {
    return file;
  }

  public void setFile(String file) {
    this.file = file;
  }

  private void setLastModified(LocalDateTime lastModified) {
    String ddMmYyyyHhMm = "dd-MM-yyyy HH:mm";
    DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern(ddMmYyyyHhMm);
    this.lastModified = dateFormat.format(lastModified);
  }

  @Override
  public Rangement getRangement() {
    return Program.getCave(emplacement);
  }

  @Override
  public int getAnneeInt() {
    if (annee.isEmpty()) {
      return 0;
    }
    try {
      int anneeInt = Integer.parseInt(annee);
      return anneeInt;
    } catch(NumberFormatException e) {
      return 0;
    }
  }

  public static boolean isInvalidYear(String year) {
    year = year.strip();
    if (!Program.hasYearControl()) {
      return false;
    }
    int n;
    try {
      n = Integer.parseInt(year);
    } catch (NumberFormatException e) {
      Debug("ERROR: Unable to parse year '" + year + "'!");
      return true;
    }

    int current_year = LocalDate.now().getYear();
    return year.length() == 4 && n > current_year;
  }

  @Override
  public double getPriceDouble() {
    String price = Program.convertStringFromHTMLString(prix);
    if (price.isEmpty()) {
      return 0;
    }

    return Program.safeStringToBigDecimal(price, BigDecimal.ZERO).doubleValue();
  }

  @Override
  public BigDecimal getPrice() {
    String price = Program.convertStringFromHTMLString(prix);
    if (price.isEmpty()) {
      return BigDecimal.ZERO;
    }

    return Program.safeStringToBigDecimal(price, BigDecimal.ZERO);
  }

  @Override
  public boolean hasPrice() {
    String price = Program.convertStringFromHTMLString(prix);
    if (price.isEmpty()) {
      return false;
    }
    try {
      Program.stringToBigDecimal(price);
    } catch (NumberFormatException ignored) {
      return false;
    }
    return true;
  }

  @Override
  public Place getPlace() {
    return new Place.PlaceBuilder(getRangement())
        .withNumPlace(getNumLieu())
        .withLine(getLigne())
        .withColumn(getColonne())
        .build();
  }

  @Override
  public boolean isNonVintage() {
    return false;
  }

  public void setMusicSupport(MusicSupport musicSupport) {
    setKind(musicSupport.name());
  }

  public MusicSupport getMusicSupport() {
    return MusicSupport.getSupport(getKind());
  }

  @Override
  public String toString() {
    return title;
  }

  public void update(final Music music) {
    setTitle(music.getTitle());
    setAnnee(music.getAnnee());
    setColonne(music.getColonne());
    setComment(music.getComment());
    setEmplacement(music.getEmplacement());
    setLigne(music.getLigne());
    setArtist(music.getArtist());
    setNumLieu(music.getNumLieu());
    setComposer(music.getComposer());
    setGenre(music.getGenre());
    setPrix(music.getPrix());
    setKind(music.getKind());
    setDuration(music.getDuration());
    setTracks(music.getTracks());
    if (music.hasNoStatus()) {
      setStatus(BottlesStatus.MODIFIED.name());
    } else {
      setStatus(music.getStatus());
    }
    setLastModified(LocalDateTime.now());
    setDiskCount(music.getDiskCount());
    setDiskNumber(music.getDiskNumber());
    setRating(music.getRating());
    setFile(music.getFile());
  }

  @Override
  public void setModified() {
    setLastModified(LocalDateTime.now());
  }

  @Override
  public void setCreated() {
    setStatus(BottlesStatus.CREATED.name());
    setLastModified(LocalDateTime.now());
  }

  @Override
  public boolean hasNoStatus() {
    return status.isEmpty() || status.equals(BottlesStatus.NONE.name());
  }

  private boolean canChangeStatus() {
    return status.isEmpty() || status.equals(BottlesStatus.NONE.name()) || status.equals(BottlesStatus.CREATED.name());
  }

  @Override
  public void updateStatus() {
    if (canChangeStatus()) {
      status = BottlesStatus.MODIFIED.name();
    }
    setModified();
  }

  @Override
  public void setValue(MyCellarFields field, String value) {
    setModified();
    switch (field) {
      case NAME:
        setTitle(value);
        break;
      case YEAR:
        setAnnee(value);
        break;
      case TYPE:
        setKind(value);
        break;
      case PLACE:
        setEmplacement(value);
        break;
      case NUM_PLACE:
        setNumLieu(Double.valueOf(value).intValue());
        break;
      case LINE:
        setLigne(Double.valueOf(value).intValue());
        break;
      case COLUMN:
        setColonne(Double.valueOf(value).intValue());
        break;
      case PRICE:
        setPrix(value);
        break;
      case COMMENT:
        setComment(value);
        break;
      case ARTIST:
        setArtist(value);
        break;
      case DURATION:
        setDuration(value);
        break;
      case COMPOSER:
        setComposer(value);
        break;
      case STATUS:
        setStatus(value);
        break;
      case DISK_NUMBER:
        setDiskNumber(Double.valueOf(value).intValue());
        break;
      case DISK_COUNT:
        setDiskCount(Double.valueOf(value).intValue());
        break;
      case RATING:
        setRating(Double.valueOf(value).intValue());
        break;
      case FILE:
        setFile(value);
        break;
      case AOC:
      case IGP:
      case PARKER:
      case VINEYARD:
      case MATURITY:
        Program.throwNotImplementedIfNotFor(this, Bouteille.class);
        break;
      default:
        break;
    }
  }

  @Override
  public boolean updateID() {
    if (id != -1) {
      final List<MyCellarObject> bouteilles = Program.getStorage().getAllList().stream().filter(bouteille -> bouteille.getId() == id).collect(Collectors.toList());
      if(bouteilles.size() == 1 && bouteilles.get(0).equals(this)) {
        return false;
      }
    }
    id = Program.getNewID();
    return true;
  }

  @Override
  public boolean isInTemporaryStock() {
    return Program.TEMP_PLACE.equalsIgnoreCase(emplacement);
  }

  public static Music fromXml(Element element) {
    return new Music().fromXmlElemnt(element);
  }

  @Override
  public Music fromXmlElemnt(Element element) {
    final int id = Integer.parseInt(getTextContent(element.getElementsByTagName("id"), "-1"));
    final String name = getTextContent(element.getElementsByTagName("title"));
    final String year = getTextContent(element.getElementsByTagName("annee"));
    final String type = getTextContent(element.getElementsByTagName("type"));
    final String place = getTextContent(element.getElementsByTagName("emplacement"));
    final int numLieu = Integer.parseInt(getTextContent(element.getElementsByTagName("num_lieu"), "0"));
    final int line = Integer.parseInt(getTextContent(element.getElementsByTagName("ligne"), "0"));
    final int column = Integer.parseInt(getTextContent(element.getElementsByTagName("colonne"), "0"));
    final String price = getTextContent(element.getElementsByTagName("prix"));
    final String comment = getTextContent(element.getElementsByTagName("comment"));
    final String artist = getTextContent(element.getElementsByTagName("artist"));
    final String composer = getTextContent(element.getElementsByTagName("composer"));
    final String genre = getTextContent(element.getElementsByTagName("genre"));
    final String duration = getTextContent(element.getElementsByTagName("duration"));
    NodeList nodeTracks = element.getElementsByTagName("tracks");
    List<Track> trackList = new LinkedList<>();
    for (int i = 0; i < nodeTracks.getLength(); i++) {
      final Element tracks = (Element) nodeTracks.item(i);
      final int trackNumber = Integer.parseInt(getTextContent(tracks.getElementsByTagName("number"), "0"));
      final String trackLabel = getTextContent(tracks.getElementsByTagName("label"));
      final String trackDuration = getTextContent(tracks.getElementsByTagName("duration"));
      final String trackComment = getTextContent(tracks.getElementsByTagName("comment"));
      final Track track = new Track();
      track.setNumber(trackNumber);
      track.setLabel(trackLabel);
      track.setDuration(trackDuration);
      track.setComment(trackComment);
      trackList.add(track);
    }

    String status = getTextContent(element.getElementsByTagName("status"));
    String lastModifed = getTextContent(element.getElementsByTagName("lastModified"));
    String file = getTextContent(element.getElementsByTagName("file"));
    int diskNumber = Integer.parseInt(getTextContent(element.getElementsByTagName("diskNumber"), "1"));
    int diskCount = Integer.parseInt(getTextContent(element.getElementsByTagName("diskCount"), "1"));
    int rating = Integer.parseInt(getTextContent(element.getElementsByTagName("rating"), "0"));

    return new MusicBuilder(name)
        .id(id)
        .annee(year)
        .musicSupport(MusicSupport.valueOf(type))
        .place(place)
        .numPlace(numLieu)
        .line(line)
        .column(column)
        .price(price)
        .comment(comment)
        .artist(artist)
        .composer(composer)
        .genre(genre)
        .status(status)
        .lastModified(lastModifed)
        .duration(duration)
        .tracks(trackList)
        .diskNumber(diskNumber)
        .diskCount(diskCount)
        .rating(rating)
        .file(file)
        .build();
  }

  /**
   * Debug
   *
   * @param sText String
   */
  private static void Debug(String sText) {
    Program.Debug("Music: " + sText);
  }

  @Override
  public int hashCode() {
    final int prime = 31;
    int result = 1;
    result = prime * result + ((annee == null) ? 0 : annee.hashCode());
    result = prime * result + colonne;
    result = prime * result + diskCount;
    result = prime * result + diskNumber;
    result = prime * result + rating;
    result = prime * result + ((duration == null) ? 0 : duration.hashCode());
    result = prime * result + ((file == null) ? 0 : file.hashCode());
    result = prime * result + ((comment == null) ? 0 : comment.hashCode());
    result = prime * result
        + ((emplacement == null) ? 0 : emplacement.hashCode());
    result = prime * result + ligne;
    result = prime * result
        + ((artist == null) ? 0 : artist.hashCode());
    result = prime * result + ((title == null) ? 0 : title.hashCode());
    result = prime * result + numLieu;
    result = prime * result + ((composer == null) ? 0 : composer.hashCode());
    result = prime * result + ((genre == null) ? 0 : genre.hashCode());
    result = prime * result + ((prix == null) ? 0 : prix.hashCode());
    result = prime * result + ((kind == null) ? 0 : kind.hashCode());
    result = prime * result + ((tracks == null) ? 0 : tracks.hashCode());
    result = prime * result + ((status == null) ? 0 : status.hashCode());
    result = prime * result + ((lastModified == null) ? 0 : lastModified.hashCode());
    return result;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    Music other = (Music) obj;
    if(id != other.id) {
      return false;
    }
    if (annee == null) {
      if (other.annee != null) {
        return false;
      }
    } else if (!annee.equals(other.annee)) {
      return false;
    }
    if (colonne != other.colonne) {
      return false;
    }
    if (duration == null) {
      if (other.duration != null) {
        return false;
      }
    } else if (!duration.equals(other.duration)) {
      return false;
    }
    if (comment == null) {
      if (other.comment != null) {
        return false;
      }
    } else if (!comment.equals(other.comment)) {
      return false;
    }
    if (emplacement == null) {
      if (other.emplacement != null) {
        return false;
      }
    } else if (!emplacement.equals(other.emplacement)) {
      return false;
    }
    if (ligne != other.ligne) {
      return false;
    }
    if (artist == null) {
      if (other.artist != null) {
        return false;
      }
    } else if (!artist.equals(other.artist)) {
      return false;
    }
    if (title == null) {
      if (other.title != null) {
        return false;
      }
    } else if (!title.equals(other.title)) {
      return false;
    }
    if (numLieu != other.numLieu) {
      return false;
    }
    if (composer == null) {
      if (other.composer != null) {
        return false;
      }
    } else if (!composer.equals(other.composer)) {
      return false;
    }
    if (genre == null) {
      if (other.genre != null) {
        return false;
      }
    } else if (!genre.equals(other.genre)) {
      return false;
    }
    if (prix == null) {
      if (other.prix != null) {
        return false;
      }
    } else if (!prix.equals(other.prix)) {
      return false;
    }
    if (kind == null) {
      if (other.kind != null) {
        return false;
      }
    } else if (!kind.equals(other.kind)) {
      return false;
    }
    if (tracks == null) {
      if (other.tracks != null) {
        return false;
      }
    } else if (!tracks.equals(other.tracks)) {
      return false;
    }
    if (status == null) {
      if (other.status != null) {
        return false;
      }
    } else if (!status.equals(other.status)) {
      return false;
    }
    if (lastModified == null) {
      if (other.lastModified != null) {
        return false;
      }
    } else if (!lastModified.equals(other.lastModified)) {
      return false;
    }
    if (diskNumber != other.diskNumber) {
      return false;
    }
    if (diskCount != other.diskCount) {
      return false;
    }
    if (rating != other.rating) {
      return false;
    }
    if (file == null) {
      if (other.file != null) {
        return false;
      }
    } else if (!file.equals(other.file)) {
      return false;
    }
    return true;
  }

  @Override
  public boolean isInExistingPlace() {
    return Program.isExistingPlace(emplacement);
  }


  public static class MusicBuilder {
    private int id;
    private final String nom;
    private String annee;
    private String type;
    private String emplacement;
    private int numLieu;
    private int ligne;
    private int colonne;
    private String prix;
    private String comment;
    private String artist;
    private String composer;
    private String genre;
    private String duration;
    private Tracks tracks;
    private String status;
    private String lastModified;
    private int diskNumber;
    private int diskCount;
    private int rating;
    private String file;

    public MusicBuilder(String nom) {
      this.nom = nom;
      id = numLieu = ligne = colonne = 0;
      type = emplacement = prix = comment = annee = artist = composer = duration = genre = file = "";
      tracks = null;
      status = "";
      lastModified = null;
    }

    private MusicBuilder id(int id) {
      this.id = id;
      return this;
    }

    public MusicBuilder annee(String annee) {
      this.annee = annee;
      return this;
    }

    public MusicBuilder musicSupport(MusicSupport musicSupport) {
      type = musicSupport.name();
      return this;
    }

    public MusicBuilder place(String place) {
      emplacement = place;
      return this;
    }

    public MusicBuilder numPlace(int num) {
      numLieu = num;
      return this;
    }

    public MusicBuilder line(int num) {
      ligne = num;
      return this;
    }

    public MusicBuilder column(int num) {
      colonne = num;
      return this;
    }

    public MusicBuilder price(String price) {
      prix = price;
      return this;
    }

    public MusicBuilder comment(String comment) {
      this.comment = comment;
      return this;
    }

    public MusicBuilder artist(String artist) {
      this.artist = artist;
      return this;
    }

    public MusicBuilder composer(String composer) {
      this.composer = composer;
      return this;
    }

    public MusicBuilder genre(String genre) {
      this.genre = genre;
      return this;
    }

    public MusicBuilder duration(String duration) {
      this.duration = duration;
      return this;
    }

    public MusicBuilder status(String status) {
      this.status = status;
      return this;
    }

    public MusicBuilder lastModified(String lastModified) {
      this.lastModified = lastModified;
      return this;
    }

    public MusicBuilder diskNumber(int diskNumber) {
      this.diskNumber = diskNumber;
      return this;
    }

    public MusicBuilder diskCount(int diskCount) {
      this.diskCount = diskCount;
      return this;
    }

    public MusicBuilder rating(int rating) {
      this.rating = rating;
      return this;
    }

    public MusicBuilder file(String file) {
      this.file = file;
      return this;
    }

    public MusicBuilder tracks(List<Track> trackList) {
      if (tracks == null) {
        tracks = new Tracks();
        tracks.setTracks(trackList);
      } else {
        tracks.getTracks().addAll(trackList);
      }
      return this;
    }

    public MusicBuilder track(int number, String label, String duration, String comment) {
      if (tracks == null) {
        tracks = new Tracks();
        tracks.setTracks(new LinkedList<>());
      }
      final Track track = new Track();
      track.setNumber(number);
      track.setLabel(label);
      track.setDuration(duration);
      track.setComment(comment);
      tracks.getTracks().add(track);
      return this;
    }

    public Music build() {
      return new Music(this);
    }
  }

}
