//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, vJAXB 2.1.10 in JDK 6 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Generated on: 2012.03.18 at 06:16:55 PM CET 
//
package mycellar.core.storage;

import mycellar.Bouteille;
import mycellar.Music;
import mycellar.Program;
import mycellar.core.MyCellarObject;
import mycellar.general.XmlUtils;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlSeeAlso;
import javax.xml.bind.annotation.XmlType;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.LinkedList;

/**
 * <p>Titre : Cave &agrave; vin</p>
 * <p>Description : Votre description</p>
 * <p>Copyright : Copyright (c) 2012</p>
 * <p>Soci&eacute;t&eacute; : Seb Informatique</p>
 *
 * @author S&eacute;bastien Duch&eacute;
 * @version 1.5
 * @since 24/08/21
 *
 * <p>Java class for anonymous complex type.
 *
 * <p>The following schema fragment specifies the expected content contained within this class.
 *
 * <pre>
 * &lt;complexType>
 *   &lt;complexContent>
 *     &lt;restriction base="{http://www.w3.org/2001/XMLSchema}anyType">
 *       &lt;sequence>
 *         &lt;element ref="{}Bouteille" maxOccurs="unbounded"/>
 *         &lt;element ref="{}Music" maxOccurs="unbounded"/>
 *       &lt;/sequence>
 *     &lt;/restriction>
 *   &lt;/complexContent>
 * &lt;/complexType>
 * </pre>
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "", propOrder = {
    "bouteille",
    "music"
})
@XmlRootElement(name = "ListeBouteille")
@XmlSeeAlso(Bouteille.class)
public class ListeBouteille {

  @XmlElement(name = "Bouteille")
  LinkedList<Bouteille> bouteille;

  @XmlElement
  LinkedList<Music> music;

  public static boolean loadXML() {
    Debug("Loading JAXB File");
    File f = new File(Program.getXMLBottlesFileName());
    return loadXML(f);
  }

  public static boolean loadXML(File f) {
    Debug("Loading XML File " + f.getAbsolutePath());
    if (!f.exists())
      return false;
    try {
      unMarshalXML(f);
      return true;
    } catch (FileNotFoundException | JAXBException e) {
      Debug("ERROR: Unable to Unmarshall JAXB File");
      Program.showException(e, false);
    }
    Debug("Manual loading of the XML file");
    try {
      manualLoadXML(f);
    } catch (ParserConfigurationException | IOException | SAXException e) {
      Debug("ERROR: Unable to load manually File");
      Program.showException(e);
      return false;
    }
    return true;
  }

  private static void manualLoadXML(File f) throws ParserConfigurationException, IOException, SAXException {
    DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
    DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
    Document doc = dBuilder.parse(f);
    doc.getDocumentElement().normalize();

    ListeBouteille listeBouteille = new ListeBouteille();
    NodeList bouteilles = doc.getElementsByTagName("Bouteille");

    for (int i = 0; i < bouteilles.getLength(); i++) {
      Node node = bouteilles.item(i);

      if (node.getNodeType() == Node.ELEMENT_NODE) {
        Element bouteilleElem = (Element) node;
        listeBouteille.getBouteille().add(Bouteille.fromXml(bouteilleElem));
      }
    }

    NodeList musics = doc.getElementsByTagName("Music");

    for (int i = 0; i < musics.getLength(); i++) {
      Node node = musics.item(i);

      if (node.getNodeType() == Node.ELEMENT_NODE) {
        Element musicElem = (Element) node;
        listeBouteille.getMusic().add(Music.fromXml(musicElem));
      }
    }
    Program.getStorage().setListMyCellarObject(listeBouteille);
    Debug("Loading Manually File Done");
  }

  private static void unMarshalXML(File f) throws JAXBException, FileNotFoundException {
    JAXBContext jc = JAXBContext.newInstance(ObjectFactory.class);
    Unmarshaller u = jc.createUnmarshaller();
    ListeBouteille lb =
        (ListeBouteille) u.unmarshal(new FileInputStream(f));
    Program.getStorage().addBouteilles(lb);
    Debug("Loading JAXB File Done");
  }

  public static boolean writeXML() {
    return XmlUtils.writeXML(Program.getStorage().getListMyCellarObject(), new File(Program.getXMLBottlesFileName()), ObjectFactory.class);
  }

  public static void writeXML(File f) {
    XmlUtils.writeXML(Program.getStorage().getListMyCellarObject(), f, ObjectFactory.class);
  }

  public static boolean writeXML(ListeBouteille liste, File f) {
    return XmlUtils.writeXML(liste, f, ObjectFactory.class);
  }

  public static void Debug(String sText) {
    Program.Debug("ListeBouteille: " + sText);
  }

  /**
   * Gets the value of the bouteille property.
   *
   * <p>
   * This accessor method returns a reference to the live list,
   * not a snapshot. Therefore any modification you make to the
   * returned list will be present inside the JAXB object.
   * This is why there is not a <CODE>set</CODE> method for the bouteille property.
   *
   * <p>
   * For example, to add a new item, do as follows:
   * <pre>
   *    getBouteille().add(newItem);
   * </pre>
   *
   *
   * <p>
   * Objects of the following type(s) are allowed in the list
   * {@link Bouteille }
   */
  public LinkedList<Bouteille> getBouteille() {
    if (bouteille == null) {
      bouteille = new LinkedList<>();
    }
    return bouteille;
  }

  public LinkedList<Music> getMusic() {
    if (music == null) {
      music = new LinkedList<>();
    }
    return music;
  }

  void resetBouteille() {
    bouteille = null;
  }

  void resetMusic() {
    music = null;
  }

  public int getItemsCount() {
    if (Program.isWineType()) {
      return bouteille.size();
    }
    if (Program.isMusicType()) {
      return music.size();
    }
    Program.throwNotImplementedIfNotFor(new Music(), Bouteille.class);
    return -1;
  }

  public boolean add(MyCellarObject myCellarObject) {
    if (myCellarObject instanceof Bouteille) {
      return getBouteille().add((Bouteille) myCellarObject);
    } else if (myCellarObject instanceof Music) {
      return getMusic().add((Music) myCellarObject);
    } else {
      Program.throwNotImplementedIfNotFor(new Music(), Bouteille.class);
      return false;
    }
  }

  public boolean remove(MyCellarObject myCellarObject) {
    if (myCellarObject instanceof Bouteille) {
      return getBouteille().remove((Bouteille) myCellarObject);
    } else if (myCellarObject instanceof Music) {
      return getMusic().remove((Music) myCellarObject);
    } else {
      Program.throwNotImplementedIfNotFor(new Music(), Bouteille.class);
    }
    return false;
  }
}
